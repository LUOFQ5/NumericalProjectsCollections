当然线性混合插值很简单，

https://github.com/brainexcerpts/Dual-Quaternion-Skinning-Sample-Codes/blob/master/quat_cu.hpp

如何用四元数旋转一个向量？

```
def quaternion_mult(q,r):
    return [r[0]*q[0]-r[1]*q[1]-r[2]*q[2]-r[3]*q[3],
            r[0]*q[1]+r[1]*q[0]-r[2]*q[3]+r[3]*q[2],
            r[0]*q[2]+r[1]*q[3]+r[2]*q[0]-r[3]*q[1],
            r[0]*q[3]-r[1]*q[2]+r[2]*q[1]+r[3]*q[0]]

def point_rotation_by_quaternion(point,q):
    r = [0]+point
    q_conj = [q[0],-1*q[1],-1*q[2],-1*q[3]]
    return quaternion_mult(quaternion_mult(q,r),q_conj)[1:]


print(point_rotation_by_quaternion([1, 0, 0],[0.7071203316249954, 0.0, 0.7071203316249954, 0.0]))
```

https://math.stackexchange.com/questions/40164/how-do-you-rotate-a-vector-by-a-unit-quaternion

上面是汉密尔顿积，那么问题又来了，这个向量是什么？是骨骼到节点的向量，看起来像是的。

那个四元数怎么来的？

```
Q56. How do I convert a rotation axis and angle to a quaternion?
----------------------------------------------------------------
  Given a rotation axis and angle, the following
  algorithm may be used to generate a quaternion:
    vector_normalize(axis);
    sin_a = sin( angle / 2 );
    cos_a = cos( angle / 2 );
    X    = axis -> x * sin_a;
    Y    = axis -> y * sin_a;
    Z    = axis -> z * sin_a;
    W    = cos_a;
  It is necessary to normalize the quaternion in case any values are
  very close to zero.
```

比如沿着x轴旋转90度，那么应就是
$$
q = \begin{bmatrix} w,x,y,z\end{bmatrix} = \begin{bmatrix} \frac{\sqrt{2}}{2},\frac{\sqrt{2}}{2},0,0\end{bmatrix}
$$
代码如下

```
print(point_rotation_by_quaternion([0, 1, 0],[0.7071203316249954,0.7071203316249954, 0.0,0.0]))
```

比如有个向量[0,1,0]，在这个向量前面加上一个零，让它成为四元数，那么再旋转就行了。