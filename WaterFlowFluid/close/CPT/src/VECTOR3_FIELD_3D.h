//////////////////////////////////////////////////////////////////////
// This file is part of Closest Point Turbulence.
// 
// Closest Point Turbulence is free software: you can redistribute it 
// and/or modify it under the terms of the GNU General Public License 
// as published by the Free Software Foundation, either version 3 of 
// the License, or (at your option) any later version.
// 
// Closest Point Turbulence is distributed in the hope that it will 
// be useful, but WITHOUT ANY WARRANTY; without even the implied 
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
// See the GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Closest Point Turbulence. 
// If not, see <http://www.gnu.org/licenses/>.
// 
// Copyright 2013 Theodore Kim and Nils Thuerey
//////////////////////////////////////////////////////////////////////

#ifndef VECTOR3_FIELD_3D_H
#define VECTOR3_FIELD_3D_H

#include <cmath>
#include <string>
#include <map>
#include <iostream>

#include "VEC3.h"
#include "FIELD_3D.h"

using namespace std;

class VECTOR3_FIELD_3D {
public:
  VECTOR3_FIELD_3D();
  VECTOR3_FIELD_3D(const int& xRes, const int& yRes, const int& zRes, const VEC3F& center = VEC3F(0,0,0), const VEC3F& lengths = VEC3F(1,1,1));
  VECTOR3_FIELD_3D(const FIELD_3D& m);
  ~VECTOR3_FIELD_3D();

  // accessors
  const VEC3F operator()(const VEC3F& position) const;
  const int xRes() const { return _xRes; };
  const int yRes() const { return _yRes; };
  const int zRes() const { return _zRes; };
  VEC3F dxs() const { return VEC3F(_dx, _dy, _dz); };
  const VEC3F center() const { return _center; };
  const VEC3F lengths() const { return _lengths; };
  inline VEC3F& operator()(int x, int y, int z) { 
    assert(x >= 0);
    assert(x < _xRes);
    assert(y >= 0);
    assert(y < _yRes);
    assert(z >= 0);
    assert(z < _zRes);
    return _data[z * _slabSize + y * _xRes + x]; 
  };
  const VEC3F operator()(int x, int y, int z) const 
  { 
    assert(x >= 0);
    assert(x < _xRes);
    assert(y >= 0);
    assert(y < _yRes);
    assert(z >= 0);
    assert(z < _zRes);
    return _data[z * _slabSize + y * _xRes + x]; 
  };
  inline VEC3F& operator[](int x) { 
    assert(x >= 0);
    assert(x < _totalCells);
    return _data[x]; 
  };
  const VEC3F operator[](int x) const { 
    assert(x >= 0);
    assert(x < _totalCells);
    return _data[x]; 
  };
  void clear();
 
  // reset the lengths to something else, and recompute all the dimesions as well
  void setLengths(const VEC3F& lengths);
  
  void setCenter(const VEC3F& center) { _center = center; };

  // create a field of the grid positions of the passed in grid
  static VECTOR3_FIELD_3D cellCenters(const FIELD_3D& input);
  
  // take the gradient of a scalar field
  static VECTOR3_FIELD_3D gradient(const FIELD_3D& input);

  // overloaded operators
  VECTOR3_FIELD_3D& operator=(const VECTOR3_FIELD_3D& input);

  // set the values in the field to the values at the closest points
  static FIELD_3D setToClosestPointValues(const FIELD_3D& input, const VECTOR3_FIELD_3D& closestPoints);
  static FIELD_3D setToClosestPointValuesNarrowBandFrozenCore(const FIELD_3D& input, const VECTOR3_FIELD_3D& closestPoints, const FIELD_3D& distance, int maxRadius, int coreRadius = 1);

  // file IO
  void readPhysBAMGz(const string filename);
  void readPhysBAMGz(const FIELD_3D& distanceField, const string filename);
  void readHoudini12(const string filename);

  // advect using first order semi-Lagrangian
  static void advectNarrowBand(const Real dt, const VECTOR3_FIELD_3D& velocityGrid, const FIELD_3D& oldField, FIELD_3D& newField, const FIELD_3D& distance, const int maxCells);
  
  // copy values out into the border, assuming that "borderSize" is the width of the grid padding
  void copyIntoBorder(int borderSize);

  // pass back a field with a new padding of size "paddingSize"
  VECTOR3_FIELD_3D withAddedPadding(int paddingSize) const;

  // compute closest point field
  //
  // For each cell center in input, compute the position of the closest point
  // in the surface field
  static void computeClosestPointsNarrowBand(const FIELD_3D& input, const FIELD_3D& surfaceField, const int maxCells, VECTOR3_FIELD_3D& final);

  // compute the extension field for some subset of points
  static FIELD_3D computeExtensionFieldMasked(const FIELD_3D& distanceField, const FIELD_3D& toExtend, const FIELD_3D& mask);

  // Clamp the extrema generated by the BFECC error correction
  static void clampExtrema(const Real dt, const VECTOR3_FIELD_3D& velocityField, const FIELD_3D& oldField, FIELD_3D& newField);
  static void clampOutsideRays(const Real dt, const VECTOR3_FIELD_3D& velocityField, const FIELD_3D& oldField, const FIELD_3D& oldAdvection, FIELD_3D& newField);

private:
  int _xRes;
  int _yRes;
  int _zRes;

  int _slabSize;
  int _totalCells;

  VEC3F* _data;

  // center position of the grid
  VEC3F _center;

  // lengths of the x,y,z dimensions of the grid
  VEC3F _lengths;

  // physical lengths
  Real _dx;
  Real _dy;
  Real _dz;

  // has this field been allocated?
  bool _initialized;
  
  // get a single closest point
  static Real getClosestPointValue(const VECTOR3_FIELD_3D& targetGradient, const VEC3F& startPosition, const FIELD_3D& distanceField, const FIELD_3D& toExtend);

  // Houdini 12 helpers
  void scanToTiles(FILE*& file);
  void readTile(FILE*& file, const int storeIndex);

  // getting nans and infs from reading in the Houdini file -- stomp them here.
  void fixNanInfs();
};

#endif
